<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>fastcgi++: http.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>http.cpp</h1><a href="http_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">/***************************************************************************</span>
<a name="l00003"></a>00003 <span class="comment">* Copyright (C) 2007 Eddie                                                 *</span>
<a name="l00004"></a>00004 <span class="comment">*                                                                          *</span>
<a name="l00005"></a>00005 <span class="comment">* This file is part of fastcgi++.                                          *</span>
<a name="l00006"></a>00006 <span class="comment">*                                                                          *</span>
<a name="l00007"></a>00007 <span class="comment">* fastcgi++ is free software: you can redistribute it and/or modify it     *</span>
<a name="l00008"></a>00008 <span class="comment">* under the terms of the GNU Lesser General Public License as  published   *</span>
<a name="l00009"></a>00009 <span class="comment">* by the Free Software Foundation, either version 3 of the License, or (at *</span>
<a name="l00010"></a>00010 <span class="comment">* your option) any later version.                                          *</span>
<a name="l00011"></a>00011 <span class="comment">*                                                                          *</span>
<a name="l00012"></a>00012 <span class="comment">* fastcgi++ is distributed in the hope that it will be useful, but WITHOUT *</span>
<a name="l00013"></a>00013 <span class="comment">* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    *</span>
<a name="l00014"></a>00014 <span class="comment">* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public     *</span>
<a name="l00015"></a>00015 <span class="comment">* License for more details.                                                *</span>
<a name="l00016"></a>00016 <span class="comment">*                                                                          *</span>
<a name="l00017"></a>00017 <span class="comment">* You should have received a copy of the GNU Lesser General Public License *</span>
<a name="l00018"></a>00018 <span class="comment">* along with fastcgi++.  If not, see &lt;http://www.gnu.org/licenses/&gt;.       *</span>
<a name="l00019"></a>00019 <span class="comment">****************************************************************************/</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="http_8hpp.html" title="Defines elements of the HTTP protocol.">fastcgi++/http.hpp</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include "<a class="code" href="utf8__codecvt_8hpp.html">utf8_codecvt.hpp</a>"</span>
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="classFastcgipp_1_1Http_1_1Address.html#3a58f93d2c3443fe478bdd3173b1c33b">00028</a> <span class="keywordtype">void</span> <a class="code" href="classFastcgipp_1_1Http_1_1Address.html#3a58f93d2c3443fe478bdd3173b1c33b" title="Assign the IPv4 address from a string of characters.">Fastcgipp::Http::Address::assign</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* start, <span class="keyword">const</span> <span class="keywordtype">char</span>* end)
<a name="l00029"></a>00029 {
<a name="l00030"></a>00030    <a class="code" href="classFastcgipp_1_1Http_1_1Address.html#5d4edb0f0082eaca1919c1f3b428a278" title="Data representation of the IPv4 address.">data</a>=0;
<a name="l00031"></a>00031    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=24; i&gt;=0; i-=8)
<a name="l00032"></a>00032    {
<a name="l00033"></a>00033       <span class="keywordtype">char</span>* point=(<span class="keywordtype">char</span>*)memchr(start, <span class="charliteral">'.'</span>, end-start);
<a name="l00034"></a>00034       <a class="code" href="classFastcgipp_1_1Http_1_1Address.html#5d4edb0f0082eaca1919c1f3b428a278" title="Data representation of the IPv4 address.">data</a>|=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(start, end)&lt;&lt;i;
<a name="l00035"></a>00035       <span class="keywordflow">if</span>(!point || point+1&gt;=end) <span class="keywordflow">break</span>;
<a name="l00036"></a>00036       start=point+1;
<a name="l00037"></a>00037    }
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">template</span> std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; Fastcgipp::Http::operator&lt;&lt; &lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; os, <span class="keyword">const</span> <a class="code" href="classFastcgipp_1_1Http_1_1Address.html" title="Efficiently stores IPv4 addresses.">Address</a>&amp; address);
<a name="l00041"></a>00041 <span class="keyword">template</span> std::basic_ostream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; Fastcgipp::Http::operator&lt;&lt; &lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;(std::basic_ostream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; os, <span class="keyword">const</span> <a class="code" href="classFastcgipp_1_1Http_1_1Address.html" title="Efficiently stores IPv4 addresses.">Address</a>&amp; address);
<a name="l00042"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#390006945c33570fed78d87a7351be0d">00042</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keywordtype">char</span>T, <span class="keyword">class</span> Traits&gt; std::basic_ostream&lt;charT, Traits&gt;&amp; Fastcgipp::Http::operator&lt;&lt;(std::basic_ostream&lt;charT, Traits&gt;&amp; os, <span class="keyword">const</span> <a class="code" href="classFastcgipp_1_1Http_1_1Address.html" title="Efficiently stores IPv4 addresses.">Address</a>&amp; address)
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044    <span class="keyword">using namespace </span>std;
<a name="l00045"></a>00045    <span class="keywordflow">if</span>(!os.good()) <span class="keywordflow">return</span> os;
<a name="l00046"></a>00046    
<a name="l00047"></a>00047    <span class="keywordflow">try</span>
<a name="l00048"></a>00048    {
<a name="l00049"></a>00049       <span class="keyword">typename</span> <a class="code" href="classstd_1_1basic__ostream.html">basic_ostream&lt;charT, Traits&gt;::sentry</a> opfx(os);
<a name="l00050"></a>00050       <span class="keywordflow">if</span>(opfx)
<a name="l00051"></a>00051       {
<a name="l00052"></a>00052          streamsize fieldWidth=os.width(0);
<a name="l00053"></a>00053          charT buffer[20];
<a name="l00054"></a>00054          charT* bufPtr=buffer;
<a name="l00055"></a>00055          locale loc(os.getloc(), <span class="keyword">new</span> num_put&lt;charT, charT*&gt;);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057          <span class="keywordflow">for</span>(uint32_t mask=0xff000000, shift=24; mask!=0; mask&gt;&gt;=8, shift-=8)
<a name="l00058"></a>00058          {
<a name="l00059"></a>00059             bufPtr=use_facet&lt;num_put&lt;charT, charT*&gt; &gt;(loc).put(bufPtr, os, os.fill(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>((address.data&amp;mask)&gt;&gt;shift));
<a name="l00060"></a>00060             *bufPtr++=os.widen(<span class="charliteral">'.'</span>);
<a name="l00061"></a>00061          }
<a name="l00062"></a>00062          --bufPtr;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064          charT* ptr=buffer;
<a name="l00065"></a>00065          ostreambuf_iterator&lt;charT,Traits&gt; sink(os);
<a name="l00066"></a>00066          <span class="keywordflow">if</span>(os.flags() &amp; ios_base::left)
<a name="l00067"></a>00067             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=max(fieldWidth, bufPtr-buffer); i&gt;0; i--)
<a name="l00068"></a>00068             {
<a name="l00069"></a>00069                <span class="keywordflow">if</span>(ptr!=bufPtr) *sink++=*ptr++;
<a name="l00070"></a>00070                <span class="keywordflow">else</span> *sink++=os.fill();
<a name="l00071"></a>00071             }
<a name="l00072"></a>00072          <span class="keywordflow">else</span>
<a name="l00073"></a>00073             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=fieldWidth-(bufPtr-buffer); ptr!=bufPtr;)
<a name="l00074"></a>00074             {
<a name="l00075"></a>00075                <span class="keywordflow">if</span>(i&gt;0) { *sink++=os.fill(); --i; }
<a name="l00076"></a>00076                <span class="keywordflow">else</span> *sink++=*ptr++;
<a name="l00077"></a>00077             }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079          <span class="keywordflow">if</span>(sink.failed()) os.setstate(ios_base::failbit);
<a name="l00080"></a>00080       }
<a name="l00081"></a>00081    }
<a name="l00082"></a>00082    <span class="keywordflow">catch</span>(bad_alloc&amp;)
<a name="l00083"></a>00083    {
<a name="l00084"></a>00084       ios_base::iostate exception_mask = os.exceptions();
<a name="l00085"></a>00085       os.exceptions(ios_base::goodbit);
<a name="l00086"></a>00086       os.setstate(ios_base::badbit);
<a name="l00087"></a>00087       os.exceptions(exception_mask);
<a name="l00088"></a>00088       <span class="keywordflow">if</span>(exception_mask &amp; ios_base::badbit) <span class="keywordflow">throw</span>;
<a name="l00089"></a>00089    }
<a name="l00090"></a>00090    <span class="keywordflow">catch</span>(...)
<a name="l00091"></a>00091    {
<a name="l00092"></a>00092       ios_base::iostate exception_mask = os.exceptions();
<a name="l00093"></a>00093       os.exceptions(ios_base::goodbit);
<a name="l00094"></a>00094       os.setstate(ios_base::failbit);
<a name="l00095"></a>00095       os.exceptions(exception_mask);
<a name="l00096"></a>00096       <span class="keywordflow">if</span>(exception_mask &amp; ios_base::failbit) <span class="keywordflow">throw</span>;
<a name="l00097"></a>00097    }
<a name="l00098"></a>00098    <span class="keywordflow">return</span> os;
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keyword">template</span> std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; Fastcgipp::Http::operator&gt;&gt; &lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_istream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; is, Address&amp; address);
<a name="l00102"></a>00102 <span class="keyword">template</span> std::basic_istream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; Fastcgipp::Http::operator&gt;&gt; &lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;(std::basic_istream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; is, Address&amp; address);
<a name="l00103"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#ea0f985f8831f536d044a23cd9082371">00103</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keywordtype">char</span>T, <span class="keyword">class</span> Traits&gt; std::basic_istream&lt;charT, Traits&gt;&amp; <a class="code" href="namespaceFastcgipp_1_1Http.html#ea0f985f8831f536d044a23cd9082371" title="Address stream extractor operation.">Fastcgipp::Http::operator&gt;&gt;</a>(std::basic_istream&lt;charT, Traits&gt;&amp; is, <a class="code" href="classFastcgipp_1_1Http_1_1Address.html" title="Efficiently stores IPv4 addresses.">Address</a>&amp; address)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105    <span class="keyword">using namespace </span>std;
<a name="l00106"></a>00106    <span class="keywordflow">if</span>(!is.good()) <span class="keywordflow">return</span> is;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108    ios_base::iostate err = ios::goodbit;
<a name="l00109"></a>00109    <span class="keywordflow">try</span>
<a name="l00110"></a>00110    {
<a name="l00111"></a>00111       <span class="keyword">typename</span> basic_istream&lt;charT, Traits&gt;::sentry ipfx(is);
<a name="l00112"></a>00112       <span class="keywordflow">if</span>(ipfx)
<a name="l00113"></a>00113       {
<a name="l00114"></a>00114          uint32_t data=0;
<a name="l00115"></a>00115          istreambuf_iterator&lt;charT, Traits&gt; it(is);
<a name="l00116"></a>00116          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=24; i&gt;=0; i-=8, ++it)
<a name="l00117"></a>00117          {
<a name="l00118"></a>00118             uint32_t value;
<a name="l00119"></a>00119             use_facet&lt;num_get&lt;charT, istreambuf_iterator&lt;charT, Traits&gt; &gt; &gt;(is.getloc()).<span class="keyword">get</span>(it, istreambuf_iterator&lt;charT, Traits&gt;(), is, err, value);
<a name="l00120"></a>00120             data|=value&lt;&lt;i;
<a name="l00121"></a>00121             <span class="keywordflow">if</span>(i &amp;&amp; *it!=is.widen(<span class="charliteral">'.'</span>)) err = ios::failbit;
<a name="l00122"></a>00122          }
<a name="l00123"></a>00123          <span class="keywordflow">if</span>(err == ios::goodbit) address=data;
<a name="l00124"></a>00124          <span class="keywordflow">else</span> is.setstate(err);
<a name="l00125"></a>00125       }
<a name="l00126"></a>00126    }
<a name="l00127"></a>00127    <span class="keywordflow">catch</span>(bad_alloc&amp;)
<a name="l00128"></a>00128    {
<a name="l00129"></a>00129       ios_base::iostate exception_mask = is.exceptions();
<a name="l00130"></a>00130       is.exceptions(ios_base::goodbit);
<a name="l00131"></a>00131       is.setstate(ios_base::badbit);
<a name="l00132"></a>00132       is.exceptions(exception_mask);
<a name="l00133"></a>00133       <span class="keywordflow">if</span>(exception_mask &amp; ios_base::badbit) <span class="keywordflow">throw</span>;
<a name="l00134"></a>00134    }
<a name="l00135"></a>00135    <span class="keywordflow">catch</span>(...)
<a name="l00136"></a>00136    {
<a name="l00137"></a>00137       ios_base::iostate exception_mask = is.exceptions();
<a name="l00138"></a>00138       is.exceptions(ios_base::goodbit);
<a name="l00139"></a>00139       is.setstate(ios_base::failbit);
<a name="l00140"></a>00140       is.exceptions(exception_mask);
<a name="l00141"></a>00141       <span class="keywordflow">if</span>(exception_mask &amp; ios_base::failbit) <span class="keywordflow">throw</span>;
<a name="l00142"></a>00142    }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144    <span class="keywordflow">return</span> is;
<a name="l00145"></a>00145 }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="keyword">template</span> <span class="keywordtype">bool</span> Fastcgipp::Http::parseXmlValue&lt;char&gt;(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> name, <span class="keyword">const</span> <span class="keywordtype">char</span>* start, <span class="keyword">const</span> <span class="keywordtype">char</span>* end, std::basic_string&lt;char&gt;&amp; string);
<a name="l00148"></a>00148 <span class="keyword">template</span> <span class="keywordtype">bool</span> Fastcgipp::Http::parseXmlValue&lt;wchar_t&gt;(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> name, <span class="keyword">const</span> <span class="keywordtype">char</span>* start, <span class="keyword">const</span> <span class="keywordtype">char</span>* end, std::basic_string&lt;wchar_t&gt;&amp; string);
<a name="l00149"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#994445486ee2251731a8265587a0c175">00149</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keywordtype">char</span>T&gt; <span class="keywordtype">bool</span> <a class="code" href="namespaceFastcgipp_1_1Http.html#994445486ee2251731a8265587a0c175" title="Finds the value associated with a name in an &amp;#39;name=&amp;quot;value&amp;quot;&amp;#39; string...">Fastcgipp::Http::parseXmlValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> name, <span class="keyword">const</span> <span class="keywordtype">char</span>* start, <span class="keyword">const</span> <span class="keywordtype">char</span>* end, std::basic_string&lt;charT&gt;&amp; <span class="keywordtype">string</span>)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151    <span class="keyword">using namespace </span>std;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153    <span class="keywordtype">size_t</span> searchStringSize=strlen(name)+2;
<a name="l00154"></a>00154    <span class="keywordtype">char</span>* searchString=<span class="keyword">new</span> <span class="keywordtype">char</span>[searchStringSize+1];
<a name="l00155"></a>00155    memcpy(searchString, name, searchStringSize-2);
<a name="l00156"></a>00156    *(searchString+searchStringSize-2)=<span class="charliteral">'='</span>;
<a name="l00157"></a>00157    *(searchString+searchStringSize-1)=<span class="charliteral">'"'</span>;
<a name="l00158"></a>00158    *(searchString+searchStringSize)=<span class="charliteral">'\0'</span>;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160    <span class="keyword">const</span> <span class="keywordtype">char</span>* valueStart=0;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162    <span class="keywordflow">for</span>(; start&lt;=end-searchStringSize; ++start)
<a name="l00163"></a>00163    {
<a name="l00164"></a>00164       <span class="keywordflow">if</span>(valueStart &amp;&amp; *start==<span class="charliteral">'"'</span>) <span class="keywordflow">break</span>;
<a name="l00165"></a>00165       <span class="keywordflow">if</span>(!memcmp(searchString, start, searchStringSize))
<a name="l00166"></a>00166       {
<a name="l00167"></a>00167          valueStart=start+searchStringSize;
<a name="l00168"></a>00168          start+=searchStringSize-1;
<a name="l00169"></a>00169       }
<a name="l00170"></a>00170    }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172    <span class="keyword">delete</span> [] searchString;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174    <span class="keywordflow">if</span>(!valueStart)
<a name="l00175"></a>00175       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177    <span class="keywordflow">if</span>(start-valueStart) <a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(valueStart, start-valueStart, <span class="keywordtype">string</span>);
<a name="l00178"></a>00178    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1">00181</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceFastcgipp_1_1Http.html#72f8c3bf833e522121f385c11082b7e8" title="Convert a char string to a std::string.">Fastcgipp::Http::charToString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size, std::wstring&amp; <span class="keywordtype">string</span>)
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183    <span class="keyword">const</span> <span class="keywordtype">size_t</span> bufferSize=512;
<a name="l00184"></a>00184    <span class="keywordtype">wchar_t</span> buffer[bufferSize];
<a name="l00185"></a>00185    <span class="keyword">using namespace </span>std;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187    <span class="keywordflow">if</span>(size)
<a name="l00188"></a>00188    {
<a name="l00189"></a>00189       codecvt_base::result cr=codecvt_base::partial;
<a name="l00190"></a>00190       <span class="keywordflow">while</span>(cr==codecvt_base::partial)
<a name="l00191"></a>00191       {{
<a name="l00192"></a>00192          <span class="keywordtype">wchar_t</span>* it;
<a name="l00193"></a>00193          <span class="keyword">const</span> <span class="keywordtype">char</span>* tmpData;
<a name="l00194"></a>00194          mbstate_t conversionState = mbstate_t();
<a name="l00195"></a>00195          cr=use_facet&lt;codecvt&lt;wchar_t, char, mbstate_t&gt; &gt;(locale(locale::classic(), <span class="keyword">new</span> utf8CodeCvt::utf8_codecvt_facet)).in(conversionState, data, data+size, tmpData, buffer, buffer+bufferSize, it);
<a name="l00196"></a>00196          <span class="keywordtype">string</span>.append(buffer, it);
<a name="l00197"></a>00197          size-=tmpData-data;
<a name="l00198"></a>00198          data=tmpData;
<a name="l00199"></a>00199       }}
<a name="l00200"></a>00200       <span class="keywordflow">if</span>(cr==codecvt_base::error) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00201"></a>00201       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00202"></a>00202    }
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99">00205</a> <span class="keywordtype">int</span> <a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">Fastcgipp::Http::atoi</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* start, <span class="keyword">const</span> <span class="keywordtype">char</span>* end)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207    <span class="keywordtype">bool</span> neg=<span class="keyword">false</span>;
<a name="l00208"></a>00208    <span class="keywordflow">if</span>(*start==<span class="charliteral">'-'</span>)
<a name="l00209"></a>00209    {
<a name="l00210"></a>00210       neg=<span class="keyword">false</span>;
<a name="l00211"></a>00211       ++start;
<a name="l00212"></a>00212    }
<a name="l00213"></a>00213    <span class="keywordtype">int</span> result=0;
<a name="l00214"></a>00214    <span class="keywordflow">for</span>(; 0x30 &lt;= *start &amp;&amp; *start &lt;= 0x39 &amp;&amp; start&lt;end; ++start)
<a name="l00215"></a>00215       result=result*10+(*start&amp;0x0f);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217    <span class="keywordflow">return</span> neg?-result:result;
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a><a class="code" href="namespaceFastcgipp_1_1Http.html#855cb3cf553acb4d4976e8f68404ba28">00220</a> <span class="keywordtype">int</span> <a class="code" href="namespaceFastcgipp_1_1Http.html#855cb3cf553acb4d4976e8f68404ba28" title="Convert a string with percent escaped byte values to their actual values.">Fastcgipp::Http::percentEscapedToRealBytes</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* destination, <span class="keywordtype">size_t</span> size)
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222    <span class="keywordtype">int</span> i=0;
<a name="l00223"></a>00223    <span class="keywordtype">char</span>* start=destination;
<a name="l00224"></a>00224    <span class="keywordflow">while</span>(1)
<a name="l00225"></a>00225    {
<a name="l00226"></a>00226       <span class="keywordflow">if</span>(*source==<span class="charliteral">'%'</span>)
<a name="l00227"></a>00227       {
<a name="l00228"></a>00228          *destination=0;
<a name="l00229"></a>00229          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> shift=4; shift&gt;=0; shift-=4)
<a name="l00230"></a>00230          {
<a name="l00231"></a>00231             <span class="keywordflow">if</span>(++i==size) <span class="keywordflow">break</span>;
<a name="l00232"></a>00232             ++source;
<a name="l00233"></a>00233             <span class="keywordflow">if</span>((*source|0x20) &gt;= <span class="charliteral">'a'</span> &amp;&amp; (*source|0x20) &lt;= <span class="charliteral">'f'</span>)
<a name="l00234"></a>00234                *destination|=(*source|0x20)-0x57&lt;&lt;shift;
<a name="l00235"></a>00235             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*source &gt;= <span class="charliteral">'0'</span> &amp;&amp; *source &lt;= <span class="charliteral">'9'</span>)
<a name="l00236"></a>00236                *destination|=(*source&amp;0x0f)&lt;&lt;shift;
<a name="l00237"></a>00237          }
<a name="l00238"></a>00238          ++source;
<a name="l00239"></a>00239          ++destination;
<a name="l00240"></a>00240          <span class="keywordflow">if</span>(++i==size) <span class="keywordflow">break</span>;
<a name="l00241"></a>00241       }
<a name="l00242"></a>00242       <span class="keywordflow">else</span>
<a name="l00243"></a>00243       {
<a name="l00244"></a>00244          *destination++=*source++;
<a name="l00245"></a>00245          <span class="keywordflow">if</span>(++i==size) <span class="keywordflow">break</span>;
<a name="l00246"></a>00246       }
<a name="l00247"></a>00247    }
<a name="l00248"></a>00248    <span class="keywordflow">return</span> destination-start;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;char&gt;::fill</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size);
<a name="l00252"></a>00252 <span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;wchar_t&gt;::fill</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size);
<a name="l00253"></a><a class="code" href="structFastcgipp_1_1Http_1_1Session.html#86f61a1dc45101f80a08a469867a5293">00253</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keywordtype">char</span>T&gt; <span class="keywordtype">bool</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;charT&gt;::fill</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size)
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255    <span class="keyword">using namespace </span>std;
<a name="l00256"></a>00256    <span class="keyword">using namespace </span>boost;
<a name="l00257"></a>00257    
<a name="l00258"></a>00258    <span class="keywordtype">bool</span> status=<span class="keyword">true</span>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260    <span class="keywordflow">while</span>(size)
<a name="l00261"></a>00261    {{
<a name="l00262"></a>00262       <span class="keywordtype">size_t</span> nameSize;
<a name="l00263"></a>00263       <span class="keywordtype">size_t</span> valueSize;
<a name="l00264"></a>00264       <span class="keyword">const</span> <span class="keywordtype">char</span>* name;
<a name="l00265"></a>00265       <span class="keyword">const</span> <span class="keywordtype">char</span>* value;
<a name="l00266"></a>00266       <span class="keywordflow">if</span>(!<a class="code" href="namespaceFastcgipp_1_1Protocol.html#80e734e52d8784e63af2d45e4489ba60" title="Process the body of a FastCGI parameter record.">Protocol::processParamHeader</a>(data, size, name, nameSize, value, valueSize)) <span class="keywordflow">return</span> <span class="keyword">false</span>;;
<a name="l00267"></a>00267       size-=value-data+valueSize;
<a name="l00268"></a>00268       data=value+valueSize;
<a name="l00269"></a>00269       
<a name="l00270"></a>00270       <span class="keywordflow">if</span>(nameSize==9 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_HOST"</span>, 9))
<a name="l00271"></a>00271          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#cee4855b5de7086d674b38bebc49f133" title="Hostname of the server.">host</a>);
<a name="l00272"></a>00272       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==15 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_USER_AGENT"</span>, 15))
<a name="l00273"></a>00273          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#450bc43fa35c02c410ffdfb4bf42362d" title="User agent string.">userAgent</a>);
<a name="l00274"></a>00274       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_ACCEPT"</span>, 11))
<a name="l00275"></a>00275          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#b3de94d839d2ca8595456d785307d103" title="Content types the client accepts.">acceptContentTypes</a>);
<a name="l00276"></a>00276       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==20 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_ACCEPT_LANGUAGE"</span>, 20))
<a name="l00277"></a>00277          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#4dd04539145de4e17ea9e71b987f51f1" title="Languages the client accepts.">acceptLanguages</a>);
<a name="l00278"></a>00278       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==19 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_ACCEPT_CHARSET"</span>, 19))
<a name="l00279"></a>00279          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#87c0c700e99c78f1a7d41d44825c2dcb" title="Character sets the clients accepts.">acceptCharsets</a>);
<a name="l00280"></a>00280       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==12 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_REFERER"</span>, 12) &amp;&amp; valueSize)
<a name="l00281"></a>00281       {
<a name="l00282"></a>00282          scoped_array&lt;char&gt; buffer(<span class="keyword">new</span> <span class="keywordtype">char</span>[valueSize]);
<a name="l00283"></a>00283          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(buffer.get(), <a class="code" href="namespaceFastcgipp_1_1Http.html#855cb3cf553acb4d4976e8f68404ba28" title="Convert a string with percent escaped byte values to their actual values.">percentEscapedToRealBytes</a>(value, buffer.get(), valueSize), <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#1e1a406d26026ded188413b13a40ae32" title="Referral URL. Percent symbol escaped bytes are converted to their actual value.">referer</a>);
<a name="l00284"></a>00284       }
<a name="l00285"></a>00285       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==12 &amp;&amp; !memcmp(name, <span class="stringliteral">"CONTENT_TYPE"</span>, 12))
<a name="l00286"></a>00286       {
<a name="l00287"></a>00287          <span class="keyword">const</span> <span class="keywordtype">char</span>* end=(<span class="keywordtype">char</span>*)memchr(value, <span class="charliteral">';'</span>, valueSize);
<a name="l00288"></a>00288          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, end?end-value:valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#7cac4792963598df46a27ad674fbdb42" title="Content type of data sent from client.">contentType</a>);
<a name="l00289"></a>00289          <span class="keywordflow">if</span>(end)
<a name="l00290"></a>00290          {
<a name="l00291"></a>00291             <span class="keyword">const</span> <span class="keywordtype">char</span>* start=(<span class="keywordtype">char</span>*)memchr(end, <span class="charliteral">'='</span>, valueSize-(end-data));
<a name="l00292"></a>00292             <span class="keywordflow">if</span>(start)
<a name="l00293"></a>00293             {
<a name="l00294"></a>00294                <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#c48d7061f693406506e182ad1c7a5de6" title="Size of boundary.">boundarySize</a>=valueSize-(++start-value);
<a name="l00295"></a>00295                <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#f074fbf696820451a71d2369c7dfe572" title="Raw string of characters representing the post boundary.">boundary</a>.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#c48d7061f693406506e182ad1c7a5de6" title="Size of boundary.">boundarySize</a>]);
<a name="l00296"></a>00296                memcpy(<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#f074fbf696820451a71d2369c7dfe572" title="Raw string of characters representing the post boundary.">boundary</a>.get(), start, boundarySize);
<a name="l00297"></a>00297             }
<a name="l00298"></a>00298          }
<a name="l00299"></a>00299       }
<a name="l00300"></a>00300       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_COOKIE"</span>, 11))
<a name="l00301"></a>00301          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#cfd4bda726916980ddc62c3579252dfc" title="Cookie string sent from the client.">cookies</a>);
<a name="l00302"></a>00302       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==13 &amp;&amp; !memcmp(name, <span class="stringliteral">"DOCUMENT_ROOT"</span>, 13))
<a name="l00303"></a>00303          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#fd2997e4240e904d865d339ed2293ea3" title="HTTP root directory.">root</a>);
<a name="l00304"></a>00304       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"SCRIPT_NAME"</span>, 11))
<a name="l00305"></a>00305          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(value, valueSize, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#2acbfb1ef8d3e2dbb57bfbcdb01931f4" title="Filename of script relative to the HTTP root directory.">scriptName</a>);
<a name="l00306"></a>00306       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==12 &amp;&amp; !memcmp(name, <span class="stringliteral">"QUERY_STRING"</span>, 12) &amp;&amp; valueSize)
<a name="l00307"></a>00307       {
<a name="l00308"></a>00308          scoped_array&lt;char&gt; buffer(<span class="keyword">new</span> <span class="keywordtype">char</span>[valueSize]);
<a name="l00309"></a>00309          status=<a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(buffer.get(), <a class="code" href="namespaceFastcgipp_1_1Http.html#855cb3cf553acb4d4976e8f68404ba28" title="Convert a string with percent escaped byte values to their actual values.">percentEscapedToRealBytes</a>(value, buffer.get(), valueSize), <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#3c2111f34c5161aefdc4829de107246c" title="Query string appended to the URL submitted by the client. Percent symbol escaped...">queryString</a>);
<a name="l00310"></a>00310       }
<a name="l00311"></a>00311       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==15 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_KEEP_ALIVE"</span>, 15))
<a name="l00312"></a>00312          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#31c02fb1aa923bf3515793312a8d3ad3" title="How many seconds the connection should be kept alive.">keepAlive</a>=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(value, value+valueSize);
<a name="l00313"></a>00313       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==14 &amp;&amp; !memcmp(name, <span class="stringliteral">"CONTENT_LENGTH"</span>, 14))
<a name="l00314"></a>00314          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#db02017849fed9216f6a4dff64449333" title="Length of content to be received from the client (post data).">contentLength</a>=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(value, value+valueSize);
<a name="l00315"></a>00315       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"SERVER_ADDR"</span>, 11))
<a name="l00316"></a>00316          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#45f99567cfe31ced3f97db3b3ca3b3c9" title="IP address of the server.">serverAddress</a>.<a class="code" href="classFastcgipp_1_1Http_1_1Address.html#3a58f93d2c3443fe478bdd3173b1c33b" title="Assign the IPv4 address from a string of characters.">assign</a>(value, value+valueSize);
<a name="l00317"></a>00317       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"REMOTE_ADDR"</span>, 11))
<a name="l00318"></a>00318          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#0ac5ae01ae6968978222223695806cbf" title="IP address of the client.">remoteAddress</a>.<a class="code" href="classFastcgipp_1_1Http_1_1Address.html#3a58f93d2c3443fe478bdd3173b1c33b" title="Assign the IPv4 address from a string of characters.">assign</a>(value, value+valueSize);
<a name="l00319"></a>00319       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"SERVER_PORT"</span>, 11))
<a name="l00320"></a>00320          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#2dc916751660f02c2152ebfea472acbb" title="TCP port used by the server.">serverPort</a>=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(value, value+valueSize);
<a name="l00321"></a>00321       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==11 &amp;&amp; !memcmp(name, <span class="stringliteral">"REMOTE_PORT"</span>, 11))
<a name="l00322"></a>00322          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#f1635a0749f209754d3b4153b6fd2d3f" title="TCP port used by the client.">remotePort</a>=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(value, value+valueSize);
<a name="l00323"></a>00323       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==22 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_IF_MODIFIED_SINCE"</span>, 22))
<a name="l00324"></a>00324       {
<a name="l00325"></a>00325          stringstream dateStream;
<a name="l00326"></a>00326          dateStream.write(value, valueSize);
<a name="l00327"></a>00327          dateStream.imbue(locale(locale::classic(), <span class="keyword">new</span> posix_time::time_input_facet(<span class="stringliteral">"%a, %d %b %Y %H:%M:%S GMT"</span>)));
<a name="l00328"></a>00328          dateStream &gt;&gt; <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#dd20d7fad2306906236eb4c1472cd2d0" title="Timestamp the client has for this document.">ifModifiedSince</a>;
<a name="l00329"></a>00329       }
<a name="l00330"></a>00330       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(nameSize==18 &amp;&amp; !memcmp(name, <span class="stringliteral">"HTTP_IF_NONE_MATCH"</span>, 18))
<a name="l00331"></a>00331          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#2419f0b495b12dad5e9745a3a0393914" title="The etag the client assumes this document should have.">etag</a>=<a class="code" href="namespaceFastcgipp_1_1Http.html#a64cb0e8d7014c2180f9b4d82a006c99" title="Convert a char string to an integer.">atoi</a>(value, value+valueSize);
<a name="l00332"></a>00332       <span class="comment">/*</span>
<a name="l00333"></a>00333 <span class="comment">      else</span>
<a name="l00334"></a>00334 <span class="comment">      {</span>
<a name="l00335"></a>00335 <span class="comment">         basic_string&lt;charT&gt; string;</span>
<a name="l00336"></a>00336 <span class="comment">         charToString(name, nameSize, string);</span>
<a name="l00337"></a>00337 <span class="comment">         charToString(value, valueSize, otherData[string]);</span>
<a name="l00338"></a>00338 <span class="comment">      }</span>
<a name="l00339"></a>00339 <span class="comment">      */</span>
<a name="l00340"></a>00340    }}
<a name="l00341"></a>00341    <span class="keywordflow">return</span> status;
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;char&gt;::fillPosts</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size);
<a name="l00345"></a>00345 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;wchar_t&gt;::fillPosts</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size);
<a name="l00346"></a><a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8b0413afb995e217f88c44bc156fe1e7">00346</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="keywordtype">char</span>T&gt; <span class="keywordtype">void</span> <a class="code" href="structFastcgipp_1_1Http_1_1Session.html" title="Data structure of HTTP session data.">Fastcgipp::Http::Session&lt;charT&gt;::fillPosts</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348    <span class="keyword">using namespace </span>std;
<a name="l00349"></a>00349    <span class="keywordflow">while</span>(1)
<a name="l00350"></a>00350    {{
<a name="l00351"></a>00351       <span class="keywordtype">size_t</span> bufferSize=<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>+size;
<a name="l00352"></a>00352       <span class="keywordtype">char</span>* buffer=<span class="keyword">new</span> <span class="keywordtype">char</span>[bufferSize];
<a name="l00353"></a>00353       <span class="keywordflow">if</span>(<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>) memcpy(buffer, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#1d4570a7b93b9b368ebee6f76778eb56" title="Buffer for processing post data.">postBuffer</a>.get(), <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>);
<a name="l00354"></a>00354       memcpy(buffer+<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>, data, size);
<a name="l00355"></a>00355       <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#1d4570a7b93b9b368ebee6f76778eb56" title="Buffer for processing post data.">postBuffer</a>.reset(buffer);
<a name="l00356"></a>00356       <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>=bufferSize;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358       <span class="keyword">const</span> <span class="keywordtype">char</span>* end=0;
<a name="l00359"></a>00359       <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">char</span>* i=buffer+<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#c48d7061f693406506e182ad1c7a5de6" title="Size of boundary.">boundarySize</a>; i&lt;buffer+bufferSize-<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#c48d7061f693406506e182ad1c7a5de6" title="Size of boundary.">boundarySize</a>; ++i)
<a name="l00360"></a>00360          <span class="keywordflow">if</span>(!memcmp(i, <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#f074fbf696820451a71d2369c7dfe572" title="Raw string of characters representing the post boundary.">boundary</a>.get(), boundarySize))
<a name="l00361"></a>00361          {
<a name="l00362"></a>00362             end=i;
<a name="l00363"></a>00363             <span class="keywordflow">break</span>;
<a name="l00364"></a>00364          }
<a name="l00365"></a>00365       
<a name="l00366"></a>00366       <span class="keywordflow">if</span>(!end)
<a name="l00367"></a>00367          <span class="keywordflow">return</span>;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369       end-=4;
<a name="l00370"></a>00370       <span class="keyword">const</span> <span class="keywordtype">char</span>* start=buffer+boundarySize+2;
<a name="l00371"></a>00371       <span class="keyword">const</span> <span class="keywordtype">char</span>* bodyStart=start;
<a name="l00372"></a>00372       <span class="keywordflow">for</span>(; bodyStart&lt;=end-4; ++bodyStart)
<a name="l00373"></a>00373          <span class="keywordflow">if</span>(!memcmp(bodyStart, <span class="stringliteral">"\r\n\r\n"</span>, 4)) <span class="keywordflow">break</span>;
<a name="l00374"></a>00374       bodyStart+=4;
<a name="l00375"></a>00375       basic_string&lt;charT&gt; name;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377       <span class="keywordflow">if</span>(<a class="code" href="namespaceFastcgipp_1_1Http.html#994445486ee2251731a8265587a0c175" title="Finds the value associated with a name in an &amp;#39;name=&amp;quot;value&amp;quot;&amp;#39; string...">parseXmlValue</a>(<span class="stringliteral">"name"</span>, start, bodyStart, name))
<a name="l00378"></a>00378       {
<a name="l00379"></a>00379          <a class="code" href="structFastcgipp_1_1Http_1_1Post.html" title="Holds a piece of HTTP post data.">Post&lt;charT&gt;</a>&amp; thePost=<a class="code" href="structFastcgipp_1_1Http_1_1Session.html#d3c19a45db3ba81a2a97e3147a960973" title="STL container associating Post objects with their name.">posts</a>[name];
<a name="l00380"></a>00380          <span class="keywordflow">if</span>(<a class="code" href="namespaceFastcgipp_1_1Http.html#994445486ee2251731a8265587a0c175" title="Finds the value associated with a name in an &amp;#39;name=&amp;quot;value&amp;quot;&amp;#39; string...">parseXmlValue</a>(<span class="stringliteral">"filename"</span>, start, bodyStart, thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#7b7dedc8dc2ee9024d9117b31e265b22" title="Value of POST data if type=form or the filename if type=file.">value</a>))
<a name="l00381"></a>00381          {
<a name="l00382"></a>00382             thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#a081e03d3866f241019f2f4542ad3108" title="Type of POST data piece.">type</a>=<a class="code" href="structFastcgipp_1_1Http_1_1Post.html" title="Holds a piece of HTTP post data.">Post&lt;charT&gt;::file</a>;
<a name="l00383"></a>00383             thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#650a03b2af12e83595e6cdfa3f0d6ce2" title="Size of data in bytes pointed to by data.">size</a>=end-bodyStart;
<a name="l00384"></a>00384             <span class="keywordflow">if</span>(thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#650a03b2af12e83595e6cdfa3f0d6ce2" title="Size of data in bytes pointed to by data.">size</a>)
<a name="l00385"></a>00385             {
<a name="l00386"></a>00386                thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#5eb592dfbd106af86bbb4341817121a3" title="Pointer to file data.">data</a>.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#650a03b2af12e83595e6cdfa3f0d6ce2" title="Size of data in bytes pointed to by data.">size</a>]);
<a name="l00387"></a>00387                memcpy(thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#5eb592dfbd106af86bbb4341817121a3" title="Pointer to file data.">data</a>.get(), bodyStart, thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#650a03b2af12e83595e6cdfa3f0d6ce2" title="Size of data in bytes pointed to by data.">size</a>);
<a name="l00388"></a>00388             }
<a name="l00389"></a>00389          }
<a name="l00390"></a>00390          <span class="keywordflow">else</span>
<a name="l00391"></a>00391          {
<a name="l00392"></a>00392             thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#a081e03d3866f241019f2f4542ad3108" title="Type of POST data piece.">type</a>=<a class="code" href="structFastcgipp_1_1Http_1_1Post.html" title="Holds a piece of HTTP post data.">Post&lt;charT&gt;::form</a>;
<a name="l00393"></a>00393             <a class="code" href="namespaceFastcgipp_1_1Http.html#b644f00b5902d3e625b50178bf41c1b1" title="Convert a char string to a std::wstring.">charToString</a>(bodyStart, end-bodyStart, thePost.<a class="code" href="structFastcgipp_1_1Http_1_1Post.html#7b7dedc8dc2ee9024d9117b31e265b22" title="Value of POST data if type=form or the filename if type=file.">value</a>);
<a name="l00394"></a>00394          }
<a name="l00395"></a>00395       }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397       bufferSize=bufferSize-(end-buffer+2);
<a name="l00398"></a>00398       <span class="keywordflow">if</span>(!bufferSize)
<a name="l00399"></a>00399       {
<a name="l00400"></a>00400          <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#1d4570a7b93b9b368ebee6f76778eb56" title="Buffer for processing post data.">postBuffer</a>.reset();
<a name="l00401"></a>00401          <span class="keywordflow">return</span>;
<a name="l00402"></a>00402       }
<a name="l00403"></a>00403       buffer=<span class="keyword">new</span> <span class="keywordtype">char</span>[bufferSize];
<a name="l00404"></a>00404       memcpy(buffer, end+2, bufferSize);
<a name="l00405"></a>00405       <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#1d4570a7b93b9b368ebee6f76778eb56" title="Buffer for processing post data.">postBuffer</a>.reset(buffer);
<a name="l00406"></a>00406       <a class="code" href="structFastcgipp_1_1Http_1_1Session.html#8a009bd63ac81809d372e9e25284aa32" title="Size of data in postBuffer.">postBufferSize</a>=bufferSize;
<a name="l00407"></a>00407       size=0;
<a name="l00408"></a>00408    }}
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 11 01:47:28 2008 for fastcgi++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
